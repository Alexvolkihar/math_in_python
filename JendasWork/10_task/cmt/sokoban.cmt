<h3>Why Sokoban?</h3>
After completing the No-left-turn solver I thought it would be a shame not to use the A* algorithm any further.
I wanted something challenging, so I chose to write sokoban in addition.

<h3>First implementation</h3>
My first naive implementation was able to solve simple square maps with up to 3 boxes. For anything else it was too slow.
To get at least vague idea of how the algorithm performs the search, I wrote some code to produce following text representation
of each step of correct solution.
<br>
<textarea rows="8" cols="12">
###########
#         #
#   $   @$#
#  .      #
#        .#
#      $  #
###########
</textarea>
<br>
Where $ is box, @ is sokoban, . is target position and # is wall.

<h3>Binary search</h3>
Before I started coding improvements on sokoban solver itself, I wanted to make 
sure, that the A* code has no bottlenecks that could be easily fixed. 

Therefore I run it with line profiler (<a href="http://pythonhosted.org/line_profiler/" style="color: rgb(0,0,150)">see this site for more info</a>)
and found out, that huge bottleneck is sorting preference queue of unvisited vertices each iteration
instead of just keeping it in sorted state. Therefore I added binary insert function which made the code 10 times faster.

<h3>Preprocessing</h3>






<iframe width="480" height="360" src="//www.youtube.com/embed/JKnl4bp18Xw" frameborder="0" allowfullscreen></iframe>

<iframe width="480" height="360" src="//www.youtube.com/embed/c0l0vZgnv04" frameborder="0" allowfullscreen></iframe>